关于Java基础以及Jvm
1. volatile的作用和原理
被volatile修饰的变量保证Java内存模型中的可见性和有序性。
可见性：当一个线程修改了一个被volatile修饰的变量的值，新值会立即被刷新到主内存中，其他线程可以立即得知新值。
有序性：禁止进行指令重排序。
指令重排序是通过什么实现的？volaitle底层是通过内存屏障来实现可见性和有序性。内存屏障是一个CPU的指令，他的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。内存屏障告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序，另一个作用是强制刷出各种CPU的缓存资源，因此任何CPU上的线程都能读取到这些数据的最新版本。
那么volatile和synchronized有啥区别？
比如 i++ volatile可能出现脏读数据，因为i++也是多个原子操作完成的，这个只能保证多个线程使用同一块内存。
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

2. Map