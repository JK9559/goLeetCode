https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug

一、缓存穿透：
是指查询一个不存在的数据，因为一直没有缓存，所以每次都去db查询
解决方案：
1. 缓存空对象，当从db查询数据为空，仍然将这个空结果缓存但是需要特殊标志，还需要设置较短的过期时间。
2. 使用布隆过滤器，根据key查询bloom缓存，如果不存在，直接返回不存在，如果存在，去查询缓存(走正常流程)

二、缓存雪崩：
是指缓存由于某些原因无法提供服务(例如，缓存挂掉了)，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。
解决方案：
1. 缓存高可用：
假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。
2. 如果缓存服务器都挂了：
可以使用本地缓存
3. 本地缓存也不好用了：
使用服务降级，提供一些空白页，限制流量

三、缓存击穿：
是指某刻很热点的数据，在某个时刻突然失效，恰好某个时间点大量请求进入db，最终db挂掉
解决方案：
1. 使用互斥锁：
在发现缓存不存在之后，查询db之前，使用分布式锁，保证有且只有一个线程去查询db，并更新到缓存：
流程：1. 获取分布式锁，直到成功或者超时。2. 查询缓存，如果存在值，则直接返回。如果不存在，继续执行
     3. 查询db，更新数据到缓存中，返回值。

2. 手动过期：
在set缓存的时候 手动在value里写入一个过期时间，在查询的时候 判断这个时间，如果过期了，
保证一个后台进程去查询db 并且更新缓存
本线程依旧返回一个旧值。伪代码看图片

db和缓存的一致性问题：
https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-database.html
1. 使用分布式锁
2. 使用定时任务
3. 使用消息队列
注意：如果高并发的情况，可能使用2. 3.都无法保证db和redis的一致，需要：
   1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = {value: 原值, version: xxx} 。
   2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。
   3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。

项目实际案例：应用在用户钱包余额的更新